<details>
  <summary>1.	什么是redis</summary>

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。

Redis 提供了多种数据类型来支持不同的业务场景，比如 String(SDS)、Hash(哈希+压缩列表)、 List (双向链表+压缩列表)、Set(哈希)、Zset(跳表)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。

除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。

</details>

<details>
  <summary>2.	为什么用 Redis 作为 MySQL 的缓存？</summary>

Redis具备高性能（访问内存）、具备高并发

Redis是单线程：接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」； 后台处理IO任务是多线程
  
</details>

<details>
  <summary>3.	Redis 采用单线程为什么还这么快？</summary>
  
Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；

Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。

Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求
</details>

<details>
  <summary>4.	Redis 如何实现数据不丢失？（持久化）</summary>

AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；

RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；

混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；

</details>

<details>
  <summary>5. AOF 日志是如何实现的？</summary>

Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。
Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。

1.避免额外的检查开销；2.不会阻塞当前写操作命令的执行。但是可能会导致数据丢失或者阻塞其他操作。
![image](https://github.com/user-attachments/assets/7cb293f4-ec15-429f-b0b8-effdf195193a)
日志过大会触发AOF重写机制
</details>

<details>
  <summary>6. RDB 做快照时会阻塞线程吗？</summary>

执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；
执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；

</details>

<details>
  <summary>7. Redis 如何实现服务高可用？</summary>

主从复制：一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。（异步）

哨兵模式：可以监控主从服务器，并且提供主从节点故障转移的功能。

切片集群：缓存数据量大到一台服务器无法缓存。
</details>

<details>
  <summary>8. 集群脑裂导致数据丢失怎么办？</summary>

当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。

</details>

<details>
  <summary>9. Redis 使用的过期删除策略是什么？</summary>

Redis 使用的过期删除策略是「惰性删除+定期删除」

惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。

定期删除：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。
</details>

<details>
  <summary>10. Redis 持久化时，对过期键会如何处理的？</summary>

RDB 文件生成阶段：过期的键「不会」被保存到新的 RDB 文件中

RDB 加载阶段：如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中。如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中

AOF 文件写入阶段：如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。

AOF 重写阶段：已过期的键不会被保存到重写后的 AOF 文件中
</details>

<details>
  <summary>11. Redis 内存淘汰策略有哪些？</summary>

1、不进行数据淘汰的策略

2、进行数据淘汰的策略（分为过期和全部数据范围2种）
  - lru（实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。）
  - lfu（多记录了「数据的访问频次」的信息）
</details>

<details>
  <summary>12. 如何避免缓存雪崩、缓存击穿、缓存穿透？</summary>

![image](https://github.com/user-attachments/assets/d91ba7f6-862e-4b4d-949d-34ad53e0978b)
</details>

<details>
  <summary>13. 常见的缓存更新策略？</summary>

Cache Aside（旁路缓存）策略适合读多写少的场景，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。
写策略的步骤：先更新数据库中的数据，再删除缓存中的数据。
读策略的步骤：如果读取的数据命中了缓存，则直接返回数据；如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

Read/Write Through（读穿 / 写穿）策略
![image](https://github.com/user-attachments/assets/1242cc82-b24d-4db0-af22-200f440c2200)

Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。

</details>


